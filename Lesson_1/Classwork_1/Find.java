public class Find {

	public static void main(String[] args) {
		int[] array = new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9};

		// System.out.print(find(array,5));
		System.out.print(binarySearch(array, 9));
	}

	/**
	 * Поиск перебором.
	 * Самый просто в реализации и понимании
	 * способ – это перебор всего массива до тех пор, пока не встретится искомый
	 * элемент.
	 * Как несложно понять, благодаря использованию цикла for, мы получаем
	 * классическую сложность обхода массива - O(n). Это неплохая сложность, но при
	 * работе с большими массивами и при регулярном поиске может стать проблемой.
	 * Можно ли найти что-то в массиве быстрее? В массиве, где данные расположены в
	 * случайном порядке, создать какой-либо универсальный алгоритм, который бы
	 * выдавал устойчивый результат, превышающий эффективность классического
	 * перебора не представляется реальным. Да, возможно какой-либо конкретный
	 * случай может содержать определенные закономерности, которые можно
	 * использовать для этого, но универсальным такой алгоритм не станет. В таком
	 * вопросе гораздо эффективнее можно ориентироваться по отсортированному
	 * массиву данных.
	 */
	public static int find(int[] array, int value){
		for (int i = 0; i < array.length; i++) {
			if (array[i] == value) {
				return i;
			}
		}
		return -1;
	}

	/**
	 * Бинарный поиск. O(log n).
	 * Бинарный поиск - тип поискового алгоритма, который последовательно
	 * делит пополам заранее отсортированный массив данных, чтобы обнаружить
	 * нужный элемент. Другие его названия — двоичный поиск, метод половинного
	 * деления, дихотомия. Принцип работы алгоритма бинарного поиска. Основная
	 * последовательность действий алгоритма выглядит так: Сортируем массив
	 * данных. Делим его пополам и находим середину.
	 * Этот алгоритм использует сортировку массива для пропуска большей части данных
	 * при поиске. Бинарный поиск начинается с середины массива, где сразу получает
	 * данные в какой части массива может находится искомый элемент – если
	 * центральный элемент массива меньше искомого – значит искомый в правой части
	 * массива. Если больше – значит в левой. Далее применяется аналогичная проверка
	 * для выбранной половины данных, снова через сравнение центрального элемента
	 * отрезка.
	 * Таким образом, при поиске элемента количество операций сравнения будет
	 * существенно меньше, чем в операции поиска перебором. Более того, т.к. мы
	 * оперирует центральным элементом отрезка, чтобы сделать всего на 1 шаг больше
	 * нам необходимо увеличить количество элементов самого массива вдвое, чтобы
	 * центральный элемент массива оказался центральным для правой или левой части
	 * массива. Это яркий пример логарифмической сложности алгоритма O(log n). Таким
	 * образом, один раз потратив время на сортировку данных мы можем во много раз
	 * сократить временные затраты на многократный поиск в дальнейшем.
	 * Благодаря особенности данного алгоритма его очень просто записать с помощью
	 * рекурсии – операция сравнения абсолютно идентичная для любого из вложенных
	 * шагов.
	 * Как мы видим, функция принимает в себя границы массива, в пределах которого
	 * необходимо осуществлять поиск. Таким образом, каждый рекурсивный шаг
	 * уменьшает диапазон, в котором необходимо произвести поиск. При этом сам
	 * алгоритм не меняется.
	 * Сложность этого алгоритма – O(log n). И вложенная логика, которая требует
	 * сравнить элемент с искомым и определить куда двигаться дальше – вправо или
	 * влево. Данный алгоритм имеет сложность O(1), т.к. эта операция никак не зависит от
	 * размера массива и, по сути, оперирует всегда с 1 значением. Перемножение
	 * сложностей дает нам O(1 * log n) => O(log n). Подход, используемый бинарным
	 * поиском, разделяющий объем данных пополам на каждом шаге, называется
	 * «разделяй и властвуй». Он позволяет создавать алгоритмы со сложностями O(m *
	 * log n), где m может быть как константой (непосредственно бинарный поиск), так и
	 * непосредственно n. Зачастую такие алгоритмы сложнее, но гораздо выгоднее с
	 * точки зрения производительности, т.к. дают сложность ощутимо меньше, чем O(n2
	 * ).
	 * Это подводит нас к алгоритмам сортировки, основанным на подобном принципе.
	 */
	public static int binarySearch(int[] array, int value, int min, int max) {
		int midpoint ;

		if (max < min){
			return -1;
		} else {
			midpoint = (max - min) / 2 + min;
		}

		if (array[midpoint] < value) {
			return binarySearch(array, value, midpoint + 1, max);
		} else {
			if (array[midpoint] > value) {
				return binarySearch(array, value, min, midpoint - 1);
			} else {
				return midpoint;
			}
		}
	}

	public static int binarySearch(int[] array, int value){
		return binarySearch(array, value, 0, array.length - 1);
	}
}
